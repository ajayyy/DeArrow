import { VideoID } from "../../maze-utils/src/video";
import { fetchOembed, getChannelNameFromVideo, getUcidFromVideo, isUCID } from "../../maze-utils/src/metadataFetcher";
import Config, { ThumbnailFallbackAutogeneratedOption, ThumbnailFallbackOption, TitleFormatting } from "./config";

export function shouldReplaceTitles(videoID: VideoID | null): Promise<boolean> {
    return checkChannelOverrideOption<boolean>(videoID, "replaceTitles");
}

export function shouldReplaceTitlesFastCheck(videoID: VideoID | null): boolean | null {
    return fastChannelOverrideOption<boolean>(videoID, "replaceTitles");
}

export function shouldReplaceThumbnails(videoID: VideoID | null): Promise<boolean> {
    return checkChannelOverrideOption<boolean>(videoID, "replaceThumbnails");
}

export function shouldReplaceThumbnailsFastCheck(videoID: VideoID | null): boolean | null {
    return fastChannelOverrideOption<boolean>(videoID, "replaceThumbnails");
}

export function shouldDefaultToCustom(videoID: VideoID | null): Promise<boolean> {
    return checkChannelOverrideOption<boolean>(videoID, "defaultToCustom");
}

export function shouldDefaultToCustomFastCheck(videoID: VideoID | null): boolean | null {
    return fastChannelOverrideOption<boolean>(videoID, "defaultToCustom");
}

export function shouldUseCrowdsourcedTitles(videoID: VideoID | null): Promise<boolean> {
    return checkChannelOverrideOption<boolean>(videoID, "useCrowdsourcedTitles");
}

export function shouldUseCrowdsourcedTitlesFastCheck(videoID: VideoID | null): boolean | null {
    return fastChannelOverrideOption<boolean>(videoID, "useCrowdsourcedTitles");
}

export function getTitleFormatting(videoID: VideoID | null): Promise<TitleFormatting> {
    return checkChannelOverrideOption<number>(videoID, "titleFormatting");
}

export function shouldCleanEmojis(videoID: VideoID | null): Promise<boolean> {
    return checkChannelOverrideOption<boolean>(videoID, "shouldCleanEmojis");
}

export function getThumbnailFallbackOption(videoID: VideoID | null): Promise<ThumbnailFallbackOption> {
    return checkChannelOverrideOption<number>(videoID, "thumbnailFallback");
}

export function getThumbnailFallbackOptionFastCheck(videoID: VideoID | null): ThumbnailFallbackOption | null {
    return fastChannelOverrideOption<number>(videoID, "thumbnailFallback");
}

export function getThumbnailFallbackAutoGeneratedOption(videoID: VideoID | null): Promise<ThumbnailFallbackAutogeneratedOption> {
    return checkChannelOverrideOption<number>(videoID, "thumbnailFallbackAutogenerated");
}

export function getThumbnailFallbackAutoGeneratedOptionFastCheck(videoID: VideoID | null): ThumbnailFallbackAutogeneratedOption | null {
    return fastChannelOverrideOption<number>(videoID, "thumbnailFallbackAutogenerated");
}

async function checkChannelOverrideOption<T>(videoID: VideoID | null, option: string): Promise<T> {
    const fastCheck = fastChannelOverrideOption<T>(videoID, option);
    if (fastCheck !== null) return fastCheck;

    if (!videoID) return Config.config![option];

    const overrideTypes = getUsedOverrideTypes();
    const channelIdentifiers: string[] = [];

    if (overrideTypes.name) {
        const id = await getChannelNameFromVideo(videoID);
        if (id != null) channelIdentifiers.push(id);
    }
    if (overrideTypes.channelID) {
        const id = await getUcidFromVideo(videoID);
        if (id != null) channelIdentifiers.push(id);
    }
    if (overrideTypes.handle) {
        const id = (await fetchOembed(videoID))?.parsed.channelHandle;
        if (id != null) channelIdentifiers.push(id);
    }

    return checkChannelOverrideOptionBase(option, channelIdentifiers) ?? Config.config![option];
}

function checkChannelOverrideOptionBase<T>(option: string, channelIdentifiers: string[]): T | null {
    const overrideOptions = channelIdentifiers
        .map((id) => Config.config!.channelOverrides[id])
        .filter((x) => x != null);

    for (const override of overrideOptions) {
        if (
            override &&
            Config.config!.customConfigurations[override] &&
            Config.config!.customConfigurations[override][option] != null
        ) {
            return Config.config!.customConfigurations[override][option];
        }
    }

    return null;
}

/**
 * Checks if it this variable has any custom config, if not it will return the known value
 */
function fastChannelOverrideOption<T>(videoID: VideoID | null, option: string): T | null {
    const mainValue = Config.config![option];

    if (videoID == null || Object.values(Config.config!.customConfigurations).every(c => c[option] == null || c[option] === mainValue)) {
        // no config overrides the main option value
        return mainValue
    }

    const overrideTypes = getUsedOverrideTypes();
    const channelIdentifiers: string[] = [];

    if (overrideTypes.name) {
        const id = getChannelNameFromVideo(videoID).peek();
        if (id != null) channelIdentifiers.push(id);
    }
    if (overrideTypes.channelID) {
        const id = getUcidFromVideo(videoID).peek();
        if (id != null) channelIdentifiers.push(id);
    }
    if (overrideTypes.handle) {
        const id = (fetchOembed(videoID).peek())?.parsed.channelHandle;
        if (id != null) channelIdentifiers.push(id);
    }

    return checkChannelOverrideOptionBase(option, channelIdentifiers);
}

interface UsedOverrideTypes {
    handle: boolean;
    channelID: boolean;
    name: boolean;
}

function getUsedOverrideTypes(): UsedOverrideTypes {
    const res = {
        handle: false,
        channelID: false,
        name: false,
    };

    for (const override of Object.keys(Config.config!.channelOverrides)) {
        res.handle ||= override[0] === "@";
        res.channelID ||= isUCID(override);
        res.name ||= override[0] !== "@" && !isUCID(override);
        // if we found all types, stop iterating
        if (Object.values(res).every(x => x)) break;
    }

    return res;
}
